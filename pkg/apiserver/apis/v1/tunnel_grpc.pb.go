// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.9
// source: tunnel.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// BackendControllerClient is the client API for BackendController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BackendControllerClient interface {
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
	// WatchTunnels watch the changes of tunnels on the server side
	WatchTunnels(ctx context.Context, in *WatchTunnelsRequest, opts ...grpc.CallOption) (BackendController_WatchTunnelsClient, error)
	// ConnectTunnel attempt to connect tunnel using token
	ConnectTunnel(ctx context.Context, opts ...grpc.CallOption) (BackendController_ConnectTunnelClient, error)
}

type backendControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewBackendControllerClient(cc grpc.ClientConnInterface) BackendControllerClient {
	return &backendControllerClient{cc}
}

func (c *backendControllerClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) {
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, "/apiserver.api.v1.BackendController/Login", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendControllerClient) WatchTunnels(ctx context.Context, in *WatchTunnelsRequest, opts ...grpc.CallOption) (BackendController_WatchTunnelsClient, error) {
	stream, err := c.cc.NewStream(ctx, &BackendController_ServiceDesc.Streams[0], "/apiserver.api.v1.BackendController/WatchTunnels", opts...)
	if err != nil {
		return nil, err
	}
	x := &backendControllerWatchTunnelsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BackendController_WatchTunnelsClient interface {
	Recv() (*WatchTunnelsResponse, error)
	grpc.ClientStream
}

type backendControllerWatchTunnelsClient struct {
	grpc.ClientStream
}

func (x *backendControllerWatchTunnelsClient) Recv() (*WatchTunnelsResponse, error) {
	m := new(WatchTunnelsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *backendControllerClient) ConnectTunnel(ctx context.Context, opts ...grpc.CallOption) (BackendController_ConnectTunnelClient, error) {
	stream, err := c.cc.NewStream(ctx, &BackendController_ServiceDesc.Streams[1], "/apiserver.api.v1.BackendController/ConnectTunnel", opts...)
	if err != nil {
		return nil, err
	}
	x := &backendControllerConnectTunnelClient{stream}
	return x, nil
}

type BackendController_ConnectTunnelClient interface {
	Send(*TunnelMessage) error
	Recv() (*TunnelMessage, error)
	grpc.ClientStream
}

type backendControllerConnectTunnelClient struct {
	grpc.ClientStream
}

func (x *backendControllerConnectTunnelClient) Send(m *TunnelMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *backendControllerConnectTunnelClient) Recv() (*TunnelMessage, error) {
	m := new(TunnelMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// BackendControllerServer is the server API for BackendController service.
// All implementations must embed UnimplementedBackendControllerServer
// for forward compatibility
type BackendControllerServer interface {
	Login(context.Context, *LoginRequest) (*LoginResponse, error)
	// WatchTunnels watch the changes of tunnels on the server side
	WatchTunnels(*WatchTunnelsRequest, BackendController_WatchTunnelsServer) error
	// ConnectTunnel attempt to connect tunnel using token
	ConnectTunnel(BackendController_ConnectTunnelServer) error
	mustEmbedUnimplementedBackendControllerServer()
}

// UnimplementedBackendControllerServer must be embedded to have forward compatible implementations.
type UnimplementedBackendControllerServer struct {
}

func (UnimplementedBackendControllerServer) Login(context.Context, *LoginRequest) (*LoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedBackendControllerServer) WatchTunnels(*WatchTunnelsRequest, BackendController_WatchTunnelsServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchTunnels not implemented")
}
func (UnimplementedBackendControllerServer) ConnectTunnel(BackendController_ConnectTunnelServer) error {
	return status.Errorf(codes.Unimplemented, "method ConnectTunnel not implemented")
}
func (UnimplementedBackendControllerServer) mustEmbedUnimplementedBackendControllerServer() {}

// UnsafeBackendControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BackendControllerServer will
// result in compilation errors.
type UnsafeBackendControllerServer interface {
	mustEmbedUnimplementedBackendControllerServer()
}

func RegisterBackendControllerServer(s grpc.ServiceRegistrar, srv BackendControllerServer) {
	s.RegisterService(&BackendController_ServiceDesc, srv)
}

func _BackendController_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendControllerServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiserver.api.v1.BackendController/Login",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendControllerServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendController_WatchTunnels_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchTunnelsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BackendControllerServer).WatchTunnels(m, &backendControllerWatchTunnelsServer{stream})
}

type BackendController_WatchTunnelsServer interface {
	Send(*WatchTunnelsResponse) error
	grpc.ServerStream
}

type backendControllerWatchTunnelsServer struct {
	grpc.ServerStream
}

func (x *backendControllerWatchTunnelsServer) Send(m *WatchTunnelsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _BackendController_ConnectTunnel_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BackendControllerServer).ConnectTunnel(&backendControllerConnectTunnelServer{stream})
}

type BackendController_ConnectTunnelServer interface {
	Send(*TunnelMessage) error
	Recv() (*TunnelMessage, error)
	grpc.ServerStream
}

type backendControllerConnectTunnelServer struct {
	grpc.ServerStream
}

func (x *backendControllerConnectTunnelServer) Send(m *TunnelMessage) error {
	return x.ServerStream.SendMsg(m)
}

func (x *backendControllerConnectTunnelServer) Recv() (*TunnelMessage, error) {
	m := new(TunnelMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// BackendController_ServiceDesc is the grpc.ServiceDesc for BackendController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BackendController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "apiserver.api.v1.BackendController",
	HandlerType: (*BackendControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Login",
			Handler:    _BackendController_Login_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchTunnels",
			Handler:       _BackendController_WatchTunnels_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ConnectTunnel",
			Handler:       _BackendController_ConnectTunnel_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "tunnel.proto",
}

// PeerControllerClient is the client API for PeerController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PeerControllerClient interface {
	// WatchTunnels watch the changes of upstreams on the server side
	WatchUpstreams(ctx context.Context, in *WatchUpstreamsRequest, opts ...grpc.CallOption) (PeerController_WatchUpstreamsClient, error)
	// ConnectUpstream attempt to connect tunnel using token
	ConnectUpstream(ctx context.Context, opts ...grpc.CallOption) (PeerController_ConnectUpstreamClient, error)
}

type peerControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewPeerControllerClient(cc grpc.ClientConnInterface) PeerControllerClient {
	return &peerControllerClient{cc}
}

func (c *peerControllerClient) WatchUpstreams(ctx context.Context, in *WatchUpstreamsRequest, opts ...grpc.CallOption) (PeerController_WatchUpstreamsClient, error) {
	stream, err := c.cc.NewStream(ctx, &PeerController_ServiceDesc.Streams[0], "/apiserver.api.v1.PeerController/WatchUpstreams", opts...)
	if err != nil {
		return nil, err
	}
	x := &peerControllerWatchUpstreamsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type PeerController_WatchUpstreamsClient interface {
	Recv() (*WatchUpstreamsResponse, error)
	grpc.ClientStream
}

type peerControllerWatchUpstreamsClient struct {
	grpc.ClientStream
}

func (x *peerControllerWatchUpstreamsClient) Recv() (*WatchUpstreamsResponse, error) {
	m := new(WatchUpstreamsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *peerControllerClient) ConnectUpstream(ctx context.Context, opts ...grpc.CallOption) (PeerController_ConnectUpstreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &PeerController_ServiceDesc.Streams[1], "/apiserver.api.v1.PeerController/ConnectUpstream", opts...)
	if err != nil {
		return nil, err
	}
	x := &peerControllerConnectUpstreamClient{stream}
	return x, nil
}

type PeerController_ConnectUpstreamClient interface {
	Send(*ConnectUpstreamRequest) error
	Recv() (*ConnectUpstreamResponse, error)
	grpc.ClientStream
}

type peerControllerConnectUpstreamClient struct {
	grpc.ClientStream
}

func (x *peerControllerConnectUpstreamClient) Send(m *ConnectUpstreamRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *peerControllerConnectUpstreamClient) Recv() (*ConnectUpstreamResponse, error) {
	m := new(ConnectUpstreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// PeerControllerServer is the server API for PeerController service.
// All implementations must embed UnimplementedPeerControllerServer
// for forward compatibility
type PeerControllerServer interface {
	// WatchTunnels watch the changes of upstreams on the server side
	WatchUpstreams(*WatchUpstreamsRequest, PeerController_WatchUpstreamsServer) error
	// ConnectUpstream attempt to connect tunnel using token
	ConnectUpstream(PeerController_ConnectUpstreamServer) error
	mustEmbedUnimplementedPeerControllerServer()
}

// UnimplementedPeerControllerServer must be embedded to have forward compatible implementations.
type UnimplementedPeerControllerServer struct {
}

func (UnimplementedPeerControllerServer) WatchUpstreams(*WatchUpstreamsRequest, PeerController_WatchUpstreamsServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchUpstreams not implemented")
}
func (UnimplementedPeerControllerServer) ConnectUpstream(PeerController_ConnectUpstreamServer) error {
	return status.Errorf(codes.Unimplemented, "method ConnectUpstream not implemented")
}
func (UnimplementedPeerControllerServer) mustEmbedUnimplementedPeerControllerServer() {}

// UnsafePeerControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PeerControllerServer will
// result in compilation errors.
type UnsafePeerControllerServer interface {
	mustEmbedUnimplementedPeerControllerServer()
}

func RegisterPeerControllerServer(s grpc.ServiceRegistrar, srv PeerControllerServer) {
	s.RegisterService(&PeerController_ServiceDesc, srv)
}

func _PeerController_WatchUpstreams_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchUpstreamsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PeerControllerServer).WatchUpstreams(m, &peerControllerWatchUpstreamsServer{stream})
}

type PeerController_WatchUpstreamsServer interface {
	Send(*WatchUpstreamsResponse) error
	grpc.ServerStream
}

type peerControllerWatchUpstreamsServer struct {
	grpc.ServerStream
}

func (x *peerControllerWatchUpstreamsServer) Send(m *WatchUpstreamsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _PeerController_ConnectUpstream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PeerControllerServer).ConnectUpstream(&peerControllerConnectUpstreamServer{stream})
}

type PeerController_ConnectUpstreamServer interface {
	Send(*ConnectUpstreamResponse) error
	Recv() (*ConnectUpstreamRequest, error)
	grpc.ServerStream
}

type peerControllerConnectUpstreamServer struct {
	grpc.ServerStream
}

func (x *peerControllerConnectUpstreamServer) Send(m *ConnectUpstreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *peerControllerConnectUpstreamServer) Recv() (*ConnectUpstreamRequest, error) {
	m := new(ConnectUpstreamRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// PeerController_ServiceDesc is the grpc.ServiceDesc for PeerController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PeerController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "apiserver.api.v1.PeerController",
	HandlerType: (*PeerControllerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchUpstreams",
			Handler:       _PeerController_WatchUpstreams_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ConnectUpstream",
			Handler:       _PeerController_ConnectUpstream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "tunnel.proto",
}
